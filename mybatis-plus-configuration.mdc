---
description: MyBatis-Plus配置和使用最佳实践，包括常用配置、插件配置和高级特性。
globs: **/src/main/resources/application*.yml, **/src/main/java/**/config/*.java
---

# MyBatis-Plus配置最佳实践

## 基础配置（application.yml）
```yaml
mybatis-plus:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
    map-underscore-to-camel-case: true
    cache-enabled: true
    lazy-loading-enabled: true
  global-config:
    db-config:
      id-type: auto  # AUTO-数据库自增, ASSIGN_ID-雪花算法, ASSIGN_UUID-UUID
      table-prefix: t_
      logic-delete-field: deleted
      logic-delete-value: 1
      logic-not-delete-value: 0
      version-field: version
    banner: false
  mapper-locations: classpath:mapper/**/*.xml
  type-aliases-package: com.example.entity
```

## 分页插件配置
```java
@Configuration
public class MybatisPlusConfig {
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        PaginationInnerInterceptor pagination = new PaginationInnerInterceptor();
        pagination.setDbType(DbType.MYSQL);
        pagination.setMaxLimit(500L);
        interceptor.addInnerInterceptor(pagination);
        interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());  // 乐观锁
        interceptor.addInnerInterceptor(new BlockAttackInnerInterceptor());  // 防止全表更新删除
        return interceptor;
    }
}
```

## 元对象字段自动填充
```java
@Component
public class MyMetaObjectHandler implements MetaObjectHandler {
    @Override
    public void insertFill(MetaObject metaObject) {
        this.strictInsertFill(metaObject, "createTime", LocalDateTime.class, LocalDateTime.now());
        this.strictInsertFill(metaObject, "updateTime", LocalDateTime.class, LocalDateTime.now());
        this.strictInsertFill(metaObject, "createBy", String.class, getCurrentUsername());
    }
    
    @Override
    public void updateFill(MetaObject metaObject) {
        this.strictUpdateFill(metaObject, "updateTime", LocalDateTime.class, LocalDateTime.now());
        this.strictUpdateFill(metaObject, "updateBy", String.class, getCurrentUsername());
    }
}
```

## Entity实体类注解
- @TableName("t_user") - 指定表名
- @TableId(type = IdType.AUTO) - 主键，AUTO/ASSIGN_ID/ASSIGN_UUID
- @TableField(select = false) - 查询时不返回
- @TableField(exist = false) - 非数据库字段
- @TableField(fill = FieldFill.INSERT) - 插入时自动填充
- @TableField(fill = FieldFill.INSERT_UPDATE) - 插入和更新时自动填充
- @TableLogic - 逻辑删除
- @Version - 乐观锁版本号

## Mapper接口定义
- 继承BaseMapper<T>获得常用CRUD方法
- 使用@Select、@Insert、@Update、@Delete注解自定义SQL
- 复杂查询使用XML映射文件
- 分页查询方法参数使用Page对象自动分页

## Service接口和实现
- Service接口继承IService<T>
- ServiceImpl继承ServiceImpl<Mapper, Entity>
- 获得常用方法：save、saveOrUpdate、saveBatch、updateBatchById、getById、lambdaQuery、lambdaUpdate

## 常用查询方式
- **LambdaQueryWrapper（推荐）**：类型安全，userMapper.selectList(new LambdaQueryWrapper<User>().eq(User::getStatus, 1).like(User::getUsername, "test"))
- **LambdaUpdateWrapper**：userService.update(new LambdaUpdateWrapper<User>().set(User::getStatus, 1).eq(User::getId, userId))
- **Service内置方法**：userService.lambdaQuery().eq(User::getStatus, 1).list()
- **动态条件**：wrapper.eq(condition, User::getField, value)

## 分页查询
```java
Page<User> page = new Page<>(current, size);
LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();
wrapper.like(StringUtils.isNotBlank(username), User::getUsername, username);
Page<User> result = userService.page(page, wrapper);
```

## 性能优化建议
- 使用LambdaQueryWrapper避免硬编码字段名
- 使用@TableField(select = false)避免查询不需要的字段
- 使用批量方法（saveBatch、updateBatchById）而不是循环单个操作
- 对大数据量使用分页查询
- 启用BlockAttackInnerInterceptor防止全表更新删除
- 复杂查询使用XML映射文件
- 使用@TableLogic实现逻辑删除避免物理删除
